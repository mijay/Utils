using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;

namespace mijay.Utils.Reflection
{
    /// <summary>
    /// Collection of extension and helper methods for types from <see cref="System.Reflection"/>.
    /// </summary>
    public static class ReflectionExtensions
    {
        private static readonly Regex backingFieldRegex = new Regex(@"^\<(?<propertyName>\w+)\>k__BackingField$",
            RegexOptions.Compiled | RegexOptions.Singleline);

        private static readonly BindingFlags instanceMember = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;

        /// <summary>
        /// Checks whether the given <paramref name="type"/> cref="type"/> is <see cref="Nullable{T}"/>.
        /// </summary>
        public static bool IsNullable(this Type type)
        {
            return type.IsGenericType && type.GetGenericTypeDefinition() == typeof (Nullable<>);
        }

        /// <summary>
        /// Gets the underlying <see cref="ValueType"/> from type of <see cref="Nullable{T}"/>.
        /// </summary>
        public static Type GetNullableUnderlyingType(this Type type)
        {
            Guard.AgainstViolation(type.IsNullable(), "Type should be nullable");
            return type.GetGenericArguments().Single();
        }

        /// <summary>
        /// Returns <paramref name="type"/> and all his base types.
        /// </summary>
        public static IEnumerable<Type> GetHierarchy(this Type type)
        {
            Type currentType = type;
            while (currentType != typeof (object)) {
                yield return currentType;
                currentType = currentType.BaseType;
            }
        }

        /// <summary>
        /// Checks whether <paramref name="type"/> implements interface, which generic definition is <paramref name="genericInterface"/>.
        /// </summary>
        public static bool ImplementsGenericInterface(this Type type, Type genericInterface)
        {
            Guard.AgainstViolation(genericInterface.IsGenericTypeDefinition && genericInterface.IsInterface,
                "Only generic interface can be used");

            return type.GetInterfaces()
                .Where(i => i.IsGenericType)
                .Select(i => i.GetGenericTypeDefinition())
                .Contains(genericInterface);
        }

        /// <summary>
        /// Checks whether <paramref name="member"/> is generated by compiler.
        /// </summary>
        public static bool IsCompilerGenerated(this MemberInfo member)
        {
            return member.HasAttribute<CompilerGeneratedAttribute>();
        }

        /// <summary>
        /// Checks whether <paramref name="property"/> is auto-implemented property.
        /// </summary>
        public static bool IsAutoProperty(this PropertyInfo property)
        {
            MethodInfo setMethod = property.GetSetMethod(true);
            MethodInfo getMethod = property.GetGetMethod(true);
            return setMethod != null && setMethod.IsCompilerGenerated()
                   && getMethod != null && getMethod.IsCompilerGenerated();
        }

        /// <summary>
        /// Returns <see cref="FieldInfo"/> of backing field for given auto-property.
        /// </summary>
        public static FieldInfo GetBackingField(this PropertyInfo property)
        {
            FieldInfo result = property.DeclaringType.GetField(
                string.Format("<{0}>k__BackingField", property.Name),
                BindingFlags.Instance | BindingFlags.NonPublic);
            Guard.AgainstViolation(result != null, "No backing field found for property {0} in {1}",
                property.Name, property.DeclaringType.FullName);

            return result;
        }

        /// <summary>
        /// Checks whether <paramref name="field"/> is a backing field for some auto-implemented property.
        /// </summary>
        public static bool IsBackingField(this FieldInfo field)
        {
            return field.IsCompilerGenerated() && backingFieldRegex.IsMatch(field.Name);
        }

        /// <summary>
        /// Tries to find auto-property that causes generation of <paramref name="field"/>, or returns <c>false</c>
        /// if <paramref name="field"/> is not auto-property backing field.
        /// </summary>
        public static bool TryGetDeclaringProperty(this FieldInfo field, out PropertyInfo declaringProperty)
        {
            if (!field.IsCompilerGenerated()) {
                declaringProperty = null;
                return false;
            }
            Match match = backingFieldRegex.Match(field.Name);
            if (!match.Success) {
                declaringProperty = null;
                return false;
            }
            declaringProperty = field.DeclaringType.GetProperty(match.Groups["propertyName"].Value,
                BindingFlags.DeclaredOnly | instanceMember);
            return declaringProperty != null;
        }

        /// <summary>
        /// Tries to find auto-event that causes generation of <paramref name="field"/>, or returns <c>false</c>
        /// if <paramref name="field"/> is not auto-event backing field.
        /// </summary>
        public static bool TryGetDeclaringEvent(this FieldInfo field, out EventInfo declaringEvent)
        {
            if (!field.IsPrivate) {
                declaringEvent = null;
                return false;
            }
            declaringEvent = field.DeclaringType.GetEvent(field.Name, BindingFlags.DeclaredOnly | instanceMember);
            return declaringEvent != null;
        }
    }
}